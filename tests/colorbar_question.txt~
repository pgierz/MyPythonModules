I'd like to adapt elements of this question: http://stackoverflow.com/questions/7404116/defining-the-midpoint-of-a-colormap-in-matplotlib

That question and the accept answer demonstrate how one could shift a colorbar using the norm optional input.


    import numpy as np
    import matplotlib
    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import AxesGrid


    def shiftedColorMap(cmap, start=0, midpoint=0.5, stop=1.0, name='shiftedcmap'):
        '''
        Function to offset the "center" of a colormap. Useful for
        data with a negative min and positive max and you want the
        middle of the colormap's dynamic range to be at zero
    
        Input
        -----
          cmap : The matplotlib colormap to be altered
          start : Offset from lowest point in the colormap's range.
              Defaults to 0.0 (no lower ofset). Should be between
              0.0 and `midpoint`.
          midpoint : The new center of the colormap. Defaults to 
              0.5 (no shift). Should be between 0.0 and 1.0. In
              general, this should be  1 - vmax/(vmax + abs(vmin))
              For example if your data range from -15.0 to +5.0 and
              you want the center of the colormap at 0.0, `midpoint`
              should be set to  1 - 5/(5 + 15)) or 0.75
          stop : Offset from highets point in the colormap's range.
              Defaults to 1.0 (no upper ofset). Should be between
              `midpoint` and 1.0.
        '''
        cdict = {
            'red': [],
            'green': [],
            'blue': [],
            'alpha': []
        }
    
        # regular index to compute the colors
        reg_index = np.linspace(start, stop, 257)
    
        # shifted index to match the data
        shift_index = np.hstack([
            np.linspace(0.0, midpoint, 128, endpoint=False), 
            np.linspace(midpoint, 1.0, 129, endpoint=True)
        ])
    
        for ri, si in zip(reg_index, shift_index):
            r, g, b, a = cmap(ri)
    
            cdict['red'].append((si, r, r))
            cdict['green'].append((si, g, g))
            cdict['blue'].append((si, b, b))
            cdict['alpha'].append((si, a, a))

        # PG: find out lengths of red, green, blue, and alpha lists
        l_red = len(cdict['red'])
        l_green = len(cdict['green'])
        l_blue = len(cdict['blue'])
        l_alpha = len(cdict['alpha'])
        # PG: And find the middle index, plus minus one on each side:
        mid_red = l_red / 2
        mid_blue = l_red / 2
        mid_green = l_red / 2
        mid_alpha = l_red / 2
        # PG: This (likely) won't work, as the middle of the colormap
        # may have been shifted
        # white in rgb is 1, 1, 1 (or 255, 255, 255)
        cdict['red'][mid_red] = 1
        cdict['blue'][mid_blue] = 1
        cdict['green'][mid_green] = 1        
        cdict['alpha'][mid_alpha] = 1
    
        newcmap = matplotlib.colors.LinearSegmentedColormap(name, cdict)
        plt.register_cmap(cmap=newcmap)
    
        return newcmap

This works wonderfully, but I'd like to extend the functionality slightly and force the colormap to have a white area around the chosen midpoint. I work with climate model output, and while the predefined colormaps in matplotlib are an excellent starting point, sometimes they are a bit limiting -- e.g., if we were plotting temperature changes over the past several decades, it would be feasible to say changes under 0.05C could be white. I've marked the parts of the code (`# PG: blah blah`) that I think should achieve this, but I haven't had any luck so far. Any help would be greatly appreciated, thanks! 
